#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass beamer
\begin_preamble
\usepackage{cibeamer}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 10
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 0
\use_package cancel 0
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 0
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%% Lecture for Artificial Intelligence, Chapter 3, http://artint.info 
\end_layout

\begin_layout Plain Layout

%% Copyright David L.
 Poole and Alan K.
 Mackworth, 2010-2013
\end_layout

\begin_layout Plain Layout

%% Copyright Peter Ljunglöf, 2015
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%% This work is licensed under CC BY-NC-SA 4.0, the Creative Commons
\end_layout

\begin_layout Plain Layout

%% Attribution-NonCommercial-ShareAlike 4.0 International License.
 
\end_layout

\begin_layout Plain Layout

%% To view a copy of this license: http://creativecommons.org/licenses/by-nc-sa/4.
0/
\end_layout

\end_inset


\end_layout

\begin_layout Title (Plain Frame)
Chapter 3: States and Searching
\end_layout

\begin_layout Subtitle
DIT410/TIN172 Artificial Intelligence
\end_layout

\begin_layout Author
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Peter Ljunglöf
\end_layout

\end_inset

Peter Ljunglöf
\begin_inset Newline newline
\end_inset

 modifed from slides by Poole & Mackworth
\begin_inset Newline newline
\end_inset

with some help from slides by Russel & Norvig
\begin_inset Newline newline
\end_inset


\size footnotesize

\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

(Licensed under Creative Commons BY-NC-SA v4.0)
\end_layout

\begin_layout Date
24, 27 March, 2015
\end_layout

\begin_layout PlainFrame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Outline
\end_layout

\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
AtBeginSubsection[]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{frame}<beamer>[plain]{Outline}
\end_layout

\begin_layout Plain Layout

    
\backslash
tableofcontents[currentsection,currentsubsection]
\end_layout

\begin_layout Plain Layout

  
\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
AtBeginSection[]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{frame}<beamer>[plain]{Outline}
\end_layout

\begin_layout Plain Layout

    
\backslash
tableofcontents[currentsection]
\end_layout

\begin_layout Plain Layout

  
\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
State spaces (3.1--3.2)
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Searching
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Often we are not given an algorithm to solve a problem, but only a specification
 of what is a solution --- we have to search for a solution.
 
\end_layout

\begin_layout Itemize
A typical problem is when the agent is in one state, it has a set of determinist
ic actions it can carry out, and wants to get to a goal state.
 
\end_layout

\begin_layout Itemize
Many AI problems can be abstracted into the problem of finding a path in
 a directed graph.
 
\end_layout

\begin_layout Itemize
Often there is more than one way to represent a problem as a graph.
 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
State-space Search: Complexity dimensions
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

flat
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 or modular or hierarchical 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

explicit states
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 or features or individuals and relations 
\end_layout

\begin_layout Itemize
static or finite stage or 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

indefinite stage
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 or infinite stage 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

fully observable
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 or partially observable 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

deterministic
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 or stochastic dynamics 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

goals
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 or complex preferences 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

single agent
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 or multiple agents 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

knowledge is given
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 or knowledge is learned 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

perfect rationality
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 or bounded rationality 
\end_layout

\end_deeper
\begin_layout Subsection
Graph searching (3.3)
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Directed Graphs
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
A 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

graph
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 consists of a set 
\begin_inset Formula $N$
\end_inset

 of 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

nodes
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 and a set 
\begin_inset Formula $A$
\end_inset

 of ordered pairs of nodes, called 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

arcs
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Itemize
Node 
\begin_inset Formula $n_{2}$
\end_inset

 is a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

neighbor
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 of 
\begin_inset Formula $n_{1}$
\end_inset

 if there is an arc from 
\begin_inset Formula $n_{1}$
\end_inset

 to 
\begin_inset Formula $n_{2}$
\end_inset

.
 That is, if 
\begin_inset Formula $\tuple{n_{1},n_{2}}\in A$
\end_inset

.
 
\end_layout

\begin_layout Itemize
A 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

path
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 is a sequence of nodes 
\begin_inset Formula $\tuple{n_{0},n_{1},\ldots,n_{k}}$
\end_inset

 such that 
\begin_inset Formula $\tuple{n_{i-1},n_{i}}\in A$
\end_inset

.
 
\end_layout

\begin_layout Itemize
The 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

length
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 of path 
\begin_inset Formula $\tuple{n_{0},n_{1},\ldots,n_{k}}$
\end_inset

 is 
\begin_inset Formula $k$
\end_inset

.
 
\end_layout

\begin_layout Itemize
A 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

solution
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 is a path from a start node to a goal node, 
\begin_inset Newline newline
\end_inset

given a set of 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

start nodes
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 and 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

goal nodes
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% 
\backslash
item When there is a 
\backslash
hiliteb{cost} associated with arcs,  the cost of a
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%   path is the sum of the costs of the arcs in the path:
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% 
\backslash

\backslash
$
\backslash
displaystyle cost(
\backslash
tuple{n_0 ,
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% n_1 ,
\backslash
ldots, n_k}) = 
\backslash
sum_{i=1}^k cost(
\backslash
tuple{n_{i-1},n_{i}})$
\backslash

\backslash

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% An 
\backslash
hiliteb{optimal solution} is one with minimum cost.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example problem: Delivery robot
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
The robot wants to get from outside room 103 to inside room 123.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/delivery-graph.pdf
	width 60text%

\end_inset

 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Delivery robot: State space graph
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/delgr-distances.pdf
	width 70text%

\end_inset

 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example problem: Travel in Romania
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
We want to drive from Arad to Bucharest in Romania.
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/romania-distances.ps
	width 90text%

\end_inset


\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example problem: Grid game
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Grid game: Rob needs to collect coins 
\begin_inset Formula $C_{1}$
\end_inset

, 
\begin_inset Formula $C_{2}$
\end_inset

, 
\begin_inset Formula $C_{3}$
\end_inset

, 
\begin_inset Formula $C_{4}$
\end_inset

, 
\begin_inset Newline newline
\end_inset

without running out of fuel, and end up at location 
\begin_inset Formula $(1,1)$
\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename figures/ch03/GameSearchSpaceSimp.pdf
	width 90text%
	BoundingBox 0bp 100bp 858bp 378bp

\end_inset


\end_layout

\begin_layout Standard
What is a good representation of the 
\begin_inset Flex Alert
status open

\begin_layout Plain Layout
search states
\end_layout

\end_inset

 and the 
\begin_inset Flex Alert
status open

\begin_layout Plain Layout
goal
\end_layout

\end_inset

?
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Grid game: State representation
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Grid game: Rob needs to collect coins 
\begin_inset Formula $C_{1}$
\end_inset

, 
\begin_inset Formula $C_{2}$
\end_inset

, 
\begin_inset Formula $C_{3}$
\end_inset

, 
\begin_inset Formula $C_{4}$
\end_inset

, 
\begin_inset Newline newline
\end_inset

without running out of fuel, and end up at location 
\begin_inset Formula $(1,1)$
\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename figures/ch03/GameSearchSpace.pdf
	width 90text%

\end_inset


\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example: The 8-puzzle
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/8-puzzle.eps
	width 60text%

\end_inset


\end_layout

\begin_layout Description
States: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
only<2>{
\end_layout

\end_inset

a 
\begin_inset Formula $3\times3$
\end_inset

 matrix of integers 
\begin_inset Formula $0\leq n\leq8$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Description
Initial
\begin_inset space ~
\end_inset

state: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
only<2>{
\end_layout

\end_inset

any state
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Description
Actions: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
only<2>{
\end_layout

\end_inset

move the blank space: left, right, up, down
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Description
Goal
\begin_inset space ~
\end_inset

test: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
only<2>{
\end_layout

\end_inset

equal to goal state (given above)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Description
Path
\begin_inset space ~
\end_inset

cost: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
only<2>{
\end_layout

\end_inset

1 per move
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example: The 8-queens problem
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/8queens.eps
	width 30text%

\end_inset


\end_layout

\begin_layout Description
States: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
only<2>{
\end_layout

\end_inset

any arrangement of 0 to 8 queens on the board
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Description
Initial
\begin_inset space ~
\end_inset

state: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
only<2>{
\end_layout

\end_inset

no queens on the board
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Description
Actions: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
only<2>{
\end_layout

\end_inset

add a queen to any empty square
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Description
Goal
\begin_inset space ~
\end_inset

test: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
only<2>{
\end_layout

\end_inset

8 queens on the board, none attacked
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Description
Path
\begin_inset space ~
\end_inset

cost: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
only<2>{
\end_layout

\end_inset

1 per move
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
only<2>{
\end_layout

\end_inset

This gives us 
\begin_inset Formula $64\cdot63\cdot\cdots57\approx1.8\times10^{14}$
\end_inset

 possible sequences to explore!
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example: The 8-queens problem (alternative)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/8queens.eps
	width 30text%

\end_inset


\end_layout

\begin_layout Description
States: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
only<2>{
\end_layout

\end_inset

one queen per column in leftmost columns 
\begin_inset Note Note
status open

\begin_layout Plain Layout
, none attacked
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Description
Initial
\begin_inset space ~
\end_inset

state: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
only<2>{
\end_layout

\end_inset

no queens on the board
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Description
Actions: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
only<2>{
\end_layout

\end_inset

add a queen to any square in the leftmost empty column, making sure that
 no queen is attacked
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Description
Goal
\begin_inset space ~
\end_inset

test: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
only<2>{
\end_layout

\end_inset

8 queens on the board, none attacked
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Description
Path
\begin_inset space ~
\end_inset

cost: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
only<2>{
\end_layout

\end_inset

1 per move
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
only<2>{
\end_layout

\end_inset

Using this formulation, we have only 2,057 sequences!
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example: robotic assembly
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/stanford-arm+blocks.ps
	width 60text%

\end_inset


\end_layout

\begin_layout Description
States: real-valued coordinates of robot joint angles 
\begin_inset Newline newline
\end_inset

parts of the object to be assembled
\end_layout

\begin_layout Description
Actions: continuous motions of robot joints
\end_layout

\begin_layout Description
Goal
\begin_inset space ~
\end_inset

test: complete assembly of the object
\end_layout

\begin_layout Description
Path
\begin_inset space ~
\end_inset

cost: time to execute 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Subsection
A generic searching algorithm (3.4)
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
How do we search in a graph?
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Generic search algorithm: given a graph, start nodes, and goal nodes, incrementa
lly explore paths from the start nodes.
 
\end_layout

\begin_layout Itemize
Maintain a 
\emph on
frontier
\emph default
 of paths from the start node that have been explored.
 
\end_layout

\begin_layout Itemize
As search proceeds, the frontier expands into the unexplored nodes until
 a goal node is encountered.
 
\end_layout

\begin_layout Itemize
The way in which the frontier is expanded defines the 
\emph on
search strategy
\emph default
.
 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Illustration of graph searching
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/searchspc.pdf
	width 70text%

\end_inset

 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
A generic graph search algorithm
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{pcode}
\end_layout

\end_inset

 
\series bold

\begin_inset Newline newline
\end_inset

procedure
\series default
 GenericSearch(
\begin_inset Formula $graph$
\end_inset

, 
\begin_inset Formula $startnodes$
\end_inset

, 
\begin_inset Formula $goal$
\end_inset

):
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset Formula $frontier:=\{\tuple{s}:s\in startnodes\}$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
while
\series default
 
\begin_inset Formula $frontier$
\end_inset

 is not empty:
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
select
\series default
 and 
\series bold
remove
\series default
 path 
\begin_inset Formula $\tuple{n_{0},\dots,n_{k}}$
\end_inset

 from 
\begin_inset Formula $frontier$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
if
\series default
 
\begin_inset Formula $goal(n_{k})$
\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
return
\series default
 
\begin_inset Formula $\tuple{n_{0},\dots,n_{k}}$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
for every
\series default
 
\begin_inset Formula $graph$
\end_inset

 neighbor 
\begin_inset Formula $n$
\end_inset

 of 
\begin_inset Formula $n_{k}$
\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
add
\series default
 
\begin_inset Formula $\tuple{n_{0},\dots,n_{k},n}$
\end_inset

 to 
\begin_inset Formula $frontier$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
end while
\series default
 
\begin_inset Newline newline
\end_inset


\series bold
end procedure
\series default
 GenericSearch
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{pcode}
\end_layout

\end_inset

 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
A generic graph search algorithm
\end_layout

\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
The search strategy is defined by which value is selected from the frontier
 at each stage.
\end_layout

\begin_layout Itemize
The graph is defined by its neighbors.
 
\end_layout

\begin_layout Itemize
The solution is defined by 
\begin_inset Formula $goal$
\end_inset

.
 
\end_layout

\begin_layout Itemize
If more than one answer is required, the search can continue from the return.
 
\end_layout

\end_deeper
\begin_layout Separator
 
\end_layout

\begin_layout Section
Uninformed search strategies
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Learning Objectives
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Plain Layout
At the end of the class you should be able to: 
\end_layout

\begin_layout Itemize
demonstrate how depth-first search will work on a graph 
\end_layout

\begin_layout Itemize
demonstrate how breadth-first search will work on a graph 
\end_layout

\begin_layout Itemize
predict the space and time requirements for depth-first and breadth-first
 searches 
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Separator

\end_layout

\begin_layout Subsection
Depth-first search (3.5.1)
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Depth-first search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Depth-first search
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 treats the frontier as a stack 
\end_layout

\begin_layout Itemize
It always selects one of the last elements added to the frontier.
 
\end_layout

\begin_layout Itemize
If the list of paths on the frontier is 
\begin_inset Formula $[p_{1},p_{2},\ldots]$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $p_{1}$
\end_inset

 is selected.
 Paths that extend 
\begin_inset Formula $p_{1}$
\end_inset

 are added to the front of the stack (in front of 
\begin_inset Formula $p_{2}$
\end_inset

).
 
\end_layout

\begin_layout Itemize
\begin_inset Formula $p_{2}$
\end_inset

 is only selected when all paths from 
\begin_inset Formula $p_{1}$
\end_inset

 have been explored.
 
\end_layout

\end_deeper
\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Illustrative graph: Depth-first search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/sgraph_de.pdf
	width 90text%

\end_inset

 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Question time: Depth-first search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Which shaded goal will a depth-first search find first?
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/sgraph_bb_template.pdf
	width 70text%

\end_inset

 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Complexity of depth-first search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Does depth-first search guarantee to find the path with fewest arcs?
\end_layout

\begin_layout Itemize
What happens on infinite graphs or on graphs with cycles if there is a solution?
\end_layout

\begin_layout Itemize
What is the time complexity as a function of length of the path selected?
\end_layout

\begin_layout Itemize
What is the space complexity as a function of length of the path selected?
\end_layout

\begin_layout Itemize
How does the goal affect the search? 
\end_layout

\end_deeper
\begin_layout Separator
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Complexity of Depth-first Search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Depth-first search isn't guaranteed to halt on infinite graphs or on graphs
 with cycles.
\end_layout

\begin_layout Itemize
The space complexity is linear in the size of the path being explored.
\end_layout

\begin_layout Itemize
Search is unconstrained by the goal until it happens to stumble on the goal.
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Separator

\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Depth-first search: Alternative formulation
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Use the internal call stack as the frontier
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Separator
 
\end_layout

\begin_layout Subsection
Breadth-first search (3.5.2)
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Breadth-first search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Breadth-first search
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 treats the frontier as a queue.
 
\end_layout

\begin_layout Itemize
It always selects one of the earliest elements added to the frontier.
 
\end_layout

\begin_layout Itemize
If the list of paths on the frontier is 
\begin_inset Formula $[p_{1},p_{2},\ldots,p_{r}]$
\end_inset

: 
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $p_{1}$
\end_inset

 is selected.
 Its neighbors are added to the end of the queue, after 
\begin_inset Formula $p_{r}$
\end_inset

.
 
\end_layout

\begin_layout Itemize
\begin_inset Formula $p_{2}$
\end_inset

 is selected next.
 
\end_layout

\end_deeper
\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Illustrative graph: breadth-first search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/sgraph_br.pdf
	width 90text%

\end_inset

 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Complexity of breadth-first search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Does breadth-first search guarantee to find the path with fewest arcs?
\end_layout

\begin_layout Itemize
What happens on infinite graphs or on graphs with cycles if there is a solution?
\end_layout

\begin_layout Itemize
What is the time complexity as a function of the length of the path selected?
\end_layout

\begin_layout Itemize
What is the space complexity as a function of the length of the path selected?
\end_layout

\begin_layout Itemize
How does the goal affect the search? 
\end_layout

\end_deeper
\begin_layout Separator
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Complexity of Breadth-first Search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Plain Layout
The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hiliteb{
\end_layout

\end_inset

branching factor
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset

 of a node is the number of its neighbors.
\end_layout

\begin_layout Itemize
If the branching factor for all nodes is finite, breadth-first search is
 guaranteed to find a solution if one exists.
 
\end_layout

\begin_deeper
\begin_layout Plain Layout
It is guaranteed to find the path with fewest arcs.
\end_layout

\end_deeper
\begin_layout Itemize
Time complexity is exponential in the path length:
\end_layout

\begin_deeper
\begin_layout Plain Layout
\begin_inset Formula $b^{n}$
\end_inset

, where 
\begin_inset Formula $b$
\end_inset

 is branching factor, 
\begin_inset Formula $n$
\end_inset

 is path length.
\end_layout

\end_deeper
\begin_layout Itemize
The space complexity is exponential in path length: 
\begin_inset Formula $b^{n}$
\end_inset

.
\end_layout

\begin_layout Itemize
Search is unconstrained by the goal.
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Question time: Breadth-first search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Which shaded goal will a breadth-first search find first?
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/sgraph_bb_template.pdf
	width 70text%

\end_inset

 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Subsection
Lowest-cost-first search (3.5.3)
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Lowest-cost-first search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Sometimes there are 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

costs
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 associated with arcs.
 The cost of a path is the sum of the costs of its arcs.
 
\begin_inset Formula 
\[
cost(\tuple{n_{0},\dots,n_{k}})=\sum_{i=1}^{k}\left|\tuple{n_{i-1},n_{i}}\right|
\]

\end_inset

An 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

optimal solution
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 is one with minimum cost.
 
\end_layout

\begin_layout Itemize
At each stage, lowest-cost-first search selects a path on the frontier with
 lowest cost.
 
\end_layout

\begin_layout Itemize
The frontier is a priority queue ordered by path cost.
 
\end_layout

\begin_layout Itemize
It finds a least-cost path to a goal node.
 
\end_layout

\begin_layout Itemize
When arc costs are equal 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
barrow
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{}
\end_layout

\end_inset

 breadth-first search.
 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Summary of Search Strategies
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="5">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
alert
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Strategy
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
alert
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Frontier Selection
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
alert
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Complete
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
alert
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Halts
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
alert
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Space
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Depth-first 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Last node added 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
uncover
\end_layout

\end_inset

<2->
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

No
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
uncover
\end_layout

\end_inset

<2->
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

No
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
uncover
\end_layout

\end_inset

<2->
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Linear
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Breadth-first 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
First node added 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
uncover
\end_layout

\end_inset

<2->
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Yes
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
uncover
\end_layout

\end_inset

<2->
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

No
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
uncover
\end_layout

\end_inset

<2->
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Exp
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lowest-cost-first 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Minimal 
\begin_inset Formula $cost(p)$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
uncover
\end_layout

\end_inset

<2->
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Yes
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
uncover
\end_layout

\end_inset

<2->
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

No
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
uncover
\end_layout

\end_inset

<2->
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Exp
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
alert
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Complete
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 --- if there a path to a goal, it can find one, even on infinite graphs.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
alert
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Halts
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 --- on finite graph (perhaps with cycles).
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
alert
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Space
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 --- as a function of the length of current path 
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Separator

\end_layout

\begin_layout Section
Heuristic search
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Learning Objectives
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Plain Layout
At the end of the class you should be able to: 
\end_layout

\begin_layout Itemize
devise an useful heuristic function for a problem 
\end_layout

\begin_layout Itemize
demonstrate how best-first and 
\begin_inset Formula $A^{*}$
\end_inset

 search will work on a graph 
\end_layout

\begin_layout Itemize
predict the space and time requirements for best-first and 
\begin_inset Formula $A^{*}$
\end_inset

 search 
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Heuristic search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%Previous methods don't use the goal to select a path to explore.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hilitec
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Idea:
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 don't ignore the goal when selecting paths.
 
\end_layout

\begin_layout Itemize
Often there is extra knowledge that can be used to guide the search: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

heuristics.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $h(n)$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 is an estimate of the cost of the shortest path from node 
\begin_inset Formula $n$
\end_inset

 to a goal node.
 
\end_layout

\begin_layout Itemize
\begin_inset Formula $h(n)$
\end_inset

 needs to be efficient to compute.
 
\end_layout

\begin_layout Itemize
\begin_inset Formula $h$
\end_inset

 can be extended to paths: 
\begin_inset Formula $h(\tuple{n_{0},\dots,n_{k}})=h(n_{k})$
\end_inset

.
 
\end_layout

\begin_layout Itemize
\begin_inset Formula $h(n)$
\end_inset

 is an 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

underestimate
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 if there is no path from 
\begin_inset Formula $n$
\end_inset

 to a goal with cost less than 
\begin_inset Formula $h(n)$
\end_inset

.
 
\end_layout

\begin_layout Itemize
An 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

admissible heuristic
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 is a nonnegative heuristic function that is an underestimate of the actual
 cost of a path to a goal.
 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example heuristic functions
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
If the nodes are points on a Euclidean plane and the cost is the distance,
 
\begin_inset Formula $h(n)$
\end_inset

 can be the straight-line distance from 
\begin_inset Formula $n$
\end_inset

 to the closest goal.
 
\end_layout

\begin_layout Itemize
If the nodes are locations and cost is time, we can use the distance to
 a goal divided by the maximum speed.
 
\end_layout

\begin_layout Itemize
If the goal is to collect all of the coins and not run out of fuel, we can
 use an estimate of how many steps it will take to collect the rest of the
 coins and return to goal position, without caring about the fuel consumption.
\end_layout

\begin_layout Itemize
A heuristic function can be found by solving a simpler (less
\begin_inset space ~
\end_inset

constrained) version of the problem.
 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example heuristic: Romania
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/romania2.ps
	width 100text%

\end_inset

 
\end_layout

\end_deeper
\begin_layout Subsection
Best-first search (3.6)
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Best-first search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hilitec
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Idea:
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 select the path whose end is closest to a goal according to the heuristic
 function.
 
\end_layout

\begin_layout Itemize
Best-first search selects a path on the frontier with minimal 
\begin_inset Formula $h$
\end_inset

-value.
 
\end_layout

\begin_layout Itemize
It treats the frontier as a priority queue ordered by 
\begin_inset Formula $h$
\end_inset

.
 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example: Romania
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
only<1>{
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/ch03/greedy-progress01c.ps
	width 100text%

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\backslash
only<2>{
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/ch03/greedy-progress02c.ps
	width 100text%

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\backslash
only<3>{
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/ch03/greedy-progress03c.ps
	width 100text%

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\backslash
only<4>{
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/ch03/greedy-progress04c.ps
	width 100text%

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Best-first search and infinite loops
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/sgraph_bestc.pdf
	width 50text%

\end_inset

 
\end_layout

\begin_layout Standard
Best-first search might fall into an infinite loop!
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Complexity of Best-first Search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Does best-first search guarantee to find the shortest path or the path with
 fewest arcs?
\end_layout

\begin_layout Itemize
What happens on infinite graphs or on graphs with cycles if there is a solution?
\end_layout

\begin_layout Itemize
What is the time complexity as a function of length of the path selected?
\end_layout

\begin_layout Itemize
What is the space complexity as a function of length of the path selected?
\end_layout

\begin_layout Itemize
How does the goal affect the search? 
\end_layout

\end_deeper
\begin_layout Separator
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Complexity of Best-first Search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
It uses space exponential in path length.
 
\end_layout

\begin_layout Itemize
It isn't guaranteed to find a solution, even if one exists.
 
\end_layout

\begin_layout Itemize
It doesn't always find the shortest path.
 
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Separator

\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Heuristic Depth-first Search
\end_layout

\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
It's a way to use heuristic knowledge in depth-first search.
 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hilitec
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Idea:
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 order the neighbors of a node (by 
\begin_inset Formula $h$
\end_inset

) before adding them to the front of the frontier.
 
\end_layout

\begin_layout Itemize
It locally selects which subtree to develop, but still does depth-first
 search.
 It explores all paths from the node at the head of the frontier before
 exploring paths from the next node.
 
\end_layout

\begin_layout Itemize
Space is linear in path length.
 It isn't guaranteed to find a solution.
 It can get led up the garden path.
 
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Separator

\end_layout

\begin_layout Subsection
\begin_inset Formula $A^{*}$
\end_inset

 search (3.6.1)
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
\begin_inset Formula $A^{*}$
\end_inset

 search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $A^{*}$
\end_inset

 search uses both path cost and heuristic values.
 
\end_layout

\begin_layout Itemize
\begin_inset Formula $cost(p)$
\end_inset

 is the cost of path 
\begin_inset Formula $p$
\end_inset

.
 
\end_layout

\begin_layout Itemize
\begin_inset Formula $h(p)$
\end_inset

 estimates the cost from the end of 
\begin_inset Formula $p$
\end_inset

 to a goal.
 
\end_layout

\begin_layout Itemize
\begin_inset Flex Alert
status open

\begin_layout Plain Layout
\begin_inset Formula $f(p)$
\end_inset


\end_layout

\end_inset


\begin_inset Formula $=cost(p)+h(p)$
\end_inset

, estimates the total path cost of going from a start node to a goal via
 
\begin_inset Formula $p$
\end_inset

: 
\begin_inset Formula 
\[
\underbrace{\underbrace{\rule[-2.5pt]{0pt}{5pt}start\;\xrightarrow{\textnormal{path }p}~n\hspace*{-0.4em}}_{{\textstyle cost(p)}}\underbrace{~\xrightarrow{\textnormal{estimate}}~goal\rule[-2.5pt]{0pt}{5pt}}_{{\textstyle h(p)}}}_{{\textstyle f(p)}}
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
\begin_inset Formula $A^{*}$
\end_inset

 search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $A^{*}$
\end_inset

 is a mix of lowest-cost-first and best-first search.
\end_layout

\begin_layout Itemize
It treats the frontier as a priority queue ordered by 
\begin_inset Formula $f(p)$
\end_inset

.
\end_layout

\begin_layout Itemize
It always selects the node on the frontier with the lowest estimated distance
 from the start to a goal node constrained to
\begin_inset space ~
\end_inset

go via that node.
 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Complexity of 
\begin_inset Formula $A^{*}$
\end_inset

 search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Does 
\begin_inset Formula $A^{*}$
\end_inset

 search guarantee to find the shortest path or the path with fewest arcs?
\end_layout

\begin_layout Itemize
What happens on infinite graphs or on graphs with cycles if there is a solution?
\end_layout

\begin_layout Itemize
What is the time complexity as a function of length of the path selected?
\end_layout

\begin_layout Itemize
What is the space complexity as a function of length of the path selected?
\end_layout

\begin_layout Itemize
How does the goal affect the search? 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example: Romania
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
only<1>{
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/ch03/astar-progress01c.ps
	width 100text%

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\backslash
only<2>{
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/ch03/astar-progress02c.ps
	width 100text%

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\backslash
only<3>{
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/ch03/astar-progress03c.ps
	width 100text%

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\backslash
only<4>{
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/ch03/astar-progress04c.ps
	width 100text%

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\backslash
only<5>{
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/ch03/astar-progress05c.ps
	width 100text%

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\backslash
only<6>{
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/ch03/astar-progress06c.ps
	width 100text%

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Admissibility (optimality) of  
\begin_inset Formula $A^{*}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
If there is a solution, 
\begin_inset Formula $A^{*}$
\end_inset

 always finds an optimal one first, if:
\end_layout

\begin_layout Itemize
the branching factor is finite,
\end_layout

\begin_layout Itemize
arc costs are bounded above zero (there is some 
\begin_inset Formula $\epsilon>0$
\end_inset

 such that all of the arc costs are greater than 
\begin_inset Formula $\epsilon$
\end_inset

), and 
\end_layout

\begin_layout Itemize
\begin_inset Formula $h(n)$
\end_inset

 is nonnegative and an underestimate of the cost of the shortest path from
 
\begin_inset Formula $n$
\end_inset

 to a goal node.
 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
\begin_inset Formula $A^{*}$
\end_inset

 always finds a solution
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $A^{*}$
\end_inset

 can always find a solution if there is one, because: 
\end_layout

\begin_layout Itemize
The frontier always contains the initial part of a path to a goal, before
 that goal is selected.
\end_layout

\begin_layout Itemize
\begin_inset Formula $A^{*}$
\end_inset

 halts, because the costs of the paths on the frontier keeps increasing,
 and will eventually exceed any finite number.
 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
\begin_inset Formula $A^{*}$
\end_inset

 finds an optimal solution first
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
The first path to a goal selected is an optimal path, because:
\end_layout

\begin_layout Itemize
The 
\begin_inset Formula $f$
\end_inset

-value for any node on an optimal solution path is less than or equal to
 the 
\begin_inset Formula $f$
\end_inset

-value of an optimal solution.
 
\end_layout

\begin_deeper
\begin_layout Itemize
this is because 
\begin_inset Formula $h$
\end_inset

 is an 
\emph on
underestimate
\emph default
 of the actual cost
\end_layout

\end_deeper
\begin_layout Itemize
Thus, the 
\begin_inset Formula $f$
\end_inset

-value of a node on an optimal solution path is less than the 
\begin_inset Formula $f$
\end_inset

-value for any non-optimal solution.
 
\end_layout

\begin_layout Itemize
Thus, a non-optimal solution can never be chosen while a node exists on
 the frontier that leads to an optimal solution.
\end_layout

\begin_deeper
\begin_layout Itemize
because an element with minimum 
\begin_inset Formula $f$
\end_inset

-value is chosen at each step
\end_layout

\end_deeper
\begin_layout Itemize
So, before it can select a non-optimal solution, it will have to pick all
 of the nodes on an optimal path, including each of the optimal solutions.
\end_layout

\end_deeper
\begin_layout Separator
\begin_inset Note Note
status open

\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Why is 
\begin_inset Formula $A^{*}$
\end_inset

 admissible?
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
If a path 
\begin_inset Formula $p$
\end_inset

 to a goal is selected from a frontier, can there be a shorter path to a
 goal? 
\end_layout

\begin_layout Itemize
Suppose path 
\begin_inset Formula $p'$
\end_inset

 is on the frontier.
 Because 
\begin_inset Formula $p$
\end_inset

 was chosen before 
\begin_inset Formula $p'$
\end_inset

, and 
\begin_inset Formula $h(p)=0$
\end_inset

: 
\begin_inset Formula 
\[
cost(p)\leq cost(p')+h(p').
\]

\end_inset


\end_layout

\begin_layout Itemize
Because 
\begin_inset Formula $h$
\end_inset

 is an underestimate: 
\begin_inset Formula 
\[
cost(p')+h(p')\leq cost(p'')
\]

\end_inset

for any path 
\begin_inset Formula $p''$
\end_inset

 to a goal that extends 
\begin_inset Formula $p'$
\end_inset

.
 
\end_layout

\begin_layout Itemize
So 
\begin_inset Formula $cost(p)\leq cost(p'')$
\end_inset

 for any other path 
\begin_inset Formula $p''$
\end_inset

 to a goal.
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Illustration: Why is 
\begin_inset Formula $A^{*}$
\end_inset

 admissible?
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $A^{*}$
\end_inset

 gradually adds 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $f$
\end_inset

-contours
\begin_inset Quotes erd
\end_inset

 of nodes (cf.
\begin_inset space ~
\end_inset

BFS adds layers).
\end_layout

\begin_layout Standard
Contour 
\begin_inset Formula $i$
\end_inset

 has all nodes with 
\begin_inset Formula $f=f_{i}$
\end_inset

, where 
\begin_inset Formula $f_{i}<f_{i+1}$
\end_inset

.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/f-circles.ps
	width 80text%

\end_inset


\end_layout

\end_deeper
\begin_layout Separator
\begin_inset Note Note
status open

\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
How do good heuristics help?
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Plain Layout
Suppose 
\begin_inset Formula $c$
\end_inset

 is the cost of an optimal solution.
 
\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Plain Layout
What happen to a path 
\begin_inset Formula $p$
\end_inset

 where 
\end_layout

\begin_layout Itemize
\begin_inset Formula $cost(p)+h(p)<c$
\end_inset

? 
\end_layout

\begin_layout Itemize
\begin_inset Formula $cost(p)+h(p)=c$
\end_inset

? 
\end_layout

\begin_layout Itemize
\begin_inset Formula $cost(p)+h(p)>c$
\end_inset

? 
\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Plain Layout
How can a better heuristic function help? 
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example: Admissible heuristics
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
For the 8-puzzle:
\end_layout

\begin_layout Standard
\begin_inset Formula $\qquad h_{1}(n)$
\end_inset

 = number of misplaced tiles
\end_layout

\begin_layout Standard
\begin_inset Formula $\qquad h_{2}(n)$
\end_inset

 = total 
\emph on
Manhattan distance
\emph default
 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(i.e., no.
\begin_inset space ~
\end_inset

of squares from desired location of each tile) 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/8-puzzle.eps
	width 50text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\qquad h_{1}(S)$
\end_inset

 = 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
alt<2>{
\end_layout

\end_inset


\begin_inset Formula $8$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}{
\end_layout

\end_inset


\begin_inset Flex Alert
status open

\begin_layout Plain Layout
??
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\qquad h_{2}(S)$
\end_inset

 = 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
alt<2>{
\end_layout

\end_inset


\begin_inset Formula $3+1+2+2+2+3+3+2=18$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}{
\end_layout

\end_inset


\begin_inset Flex Alert
status open

\begin_layout Plain Layout
??
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Dominating heuristics
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
If 
\begin_inset Formula $h_{2}(n)\geq h_{1}(n)$
\end_inset

 for all 
\begin_inset Formula $n$
\end_inset

 (both admissible), then 
\begin_inset Formula $h_{2}$
\end_inset

 
\emph on
dominates
\emph default
 
\begin_inset Formula $h_{1}$
\end_inset

 and is better for search.
 Typical search costs (for 8-puzzle):
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $depth=14$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DFS 
\begin_inset Formula $\approx$
\end_inset

 3,000,000 nodes 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A^{*}(h_{1})$
\end_inset

 = 539 nodes 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A^{*}(h_{2})$
\end_inset

 = 113 nodes 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $depth=24$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DFS 
\begin_inset Formula $\approx$
\end_inset

 54,000,000,000 nodes 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A^{*}(h_{1})$
\end_inset

 = 39,135 nodes 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A^{*}(h_{2})$
\end_inset

 = 1,641 nodes 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

Given any admissible heuristics 
\begin_inset Formula $h_{a}$
\end_inset

, 
\begin_inset Formula $h_{b}$
\end_inset

, 
\begin_inset Formula 
\begin{eqnarray*}
h(n) & = & \max(h_{a}(n),h_{b}(n))
\end{eqnarray*}

\end_inset

 is also admissible and dominates 
\begin_inset Formula $h_{a}$
\end_inset

, 
\begin_inset Formula $h_{b}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Summary of search strategies
\end_layout

\end_inset

 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{adjustwidth}{-1cm}{-1cm} % adjust the L and R margins by 1 cm
\end_layout

\begin_layout Plain Layout


\backslash
small
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="5">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Strategy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Frontier
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Halts if
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Halts if no
\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Space
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
selection
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
solution?
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
solution?
\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Depth-first 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Last node added 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
uncover
\end_layout

\end_inset

<2->
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

No
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
uncover
\end_layout

\end_inset

<2->
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

No
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
uncover
\end_layout

\end_inset

<2->
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Linear
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Breadth-first 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
First node added 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
uncover
\end_layout

\end_inset

<2->
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Yes
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
uncover
\end_layout

\end_inset

<2->
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

No
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
uncover
\end_layout

\end_inset

<2->
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Exp
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Best-first 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Global min 
\begin_inset Formula $h(p)$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
uncover
\end_layout

\end_inset

<2->
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

No
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
uncover
\end_layout

\end_inset

<2->
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

No
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
uncover
\end_layout

\end_inset

<2->
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Exp
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lowest-cost-first 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Minimal 
\begin_inset Formula $cost(p)$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
uncover
\end_layout

\end_inset

<2->
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Yes
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
uncover
\end_layout

\end_inset

<2->
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

No
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
uncover
\end_layout

\end_inset

<2->
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Exp
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A^{*}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Minimal 
\begin_inset Formula $f(p)$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
uncover
\end_layout

\end_inset

<2->
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Yes
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
uncover
\end_layout

\end_inset

<2->
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

No
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
uncover
\end_layout

\end_inset

<2->
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Exp
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{adjustwidth}
\end_layout

\end_inset


\end_layout

\begin_layout Description
Halts
\begin_inset space ~
\end_inset

if: If there a path to a goal, it can find one, even on 
\emph on
infinite graphs
\emph default
.
\end_layout

\begin_layout Description
Halts
\begin_inset space ~
\end_inset

if
\begin_inset space ~
\end_inset

no: Even if there is no solution, it will halt on a 
\emph on
finite
\begin_inset space ~
\end_inset

graph
\emph default
 (perhaps with cycles).
\end_layout

\begin_layout Description
Space: Space complexity as a function of the length of the current
\begin_inset space ~
\end_inset

path.
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example demo
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Here is an example demo of several different search algorithms, including
 
\begin_inset Formula $A^{*}$
\end_inset

.
 Furthermore you can play with different heuristics:
\end_layout

\begin_layout Standard
\align center
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://qiao.github.io/PathFinding.js/visual/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that this demo is tailor-made for planar grids, which is a special
 case of all possible search graphs.
\end_layout

\end_deeper
\begin_layout Section
More sophisticated search
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Learning Objectives
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Plain Layout
At the end of the class you should be able to: 
\end_layout

\begin_layout Itemize
explain how cycle checking and multiple-path pruning can improve efficiency
 of search algorithms 
\end_layout

\begin_layout Itemize
explain the complexity of cycle checking and multiple-path pruning for different
 search algorithms 
\end_layout

\begin_layout Itemize
justify why the monotone restriction is useful for 
\begin_inset Formula $A^{*}$
\end_inset

 search 
\end_layout

\begin_layout Itemize
predict whether forward, backward, bidirectional or island-driven search
 is better for a particular problem 
\end_layout

\begin_layout Itemize
demonstrate how dynamic programming works for a particular problem 
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Subsection
Cycle checking (3.7.1)
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example: Driving to Bucharest
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/search-map1c.ps
	width 90text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example: Driving to Bucharest
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/search-map2c.ps
	width 90text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example: Driving to Bucharest
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/search-map3c.ps
	width 90text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Alert
status open

\begin_layout Plain Layout
Note
\end_layout

\end_inset

: Arad is one of the expanded nodes! 
\begin_inset Newline newline
\end_inset

This corresponds to going to Sibiu and then returning to Arad.
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Cycle checking
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/cycle.pdf
	width 25text%

\end_inset

 
\end_layout

\begin_layout Itemize
A searcher can prune a path that ends in a node already on the path, without
 removing an optimal solution.
 
\end_layout

\begin_layout Itemize
Checking for cycles can be done in linear time (in path length)
\end_layout

\begin_deeper
\begin_layout Itemize
except for depth-first, where it can be done in constant time
\end_layout

\end_deeper
\begin_layout Itemize
Does cycle checking mean the algorithms halt on finite graphs? 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Subsection
Multiple-path pruning (3.7.2)
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Multiple-path pruning
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/mult_path.pdf
	width 50text%

\end_inset

 
\end_layout

\begin_layout Itemize
Multiple path pruning: prune a path to node 
\begin_inset Formula $n$
\end_inset

 that the searcher has already found a path to.
 
\end_layout

\begin_layout Itemize
What needs to be stored? 
\end_layout

\begin_layout Itemize
How does multiple-path pruning compare to cycle checking? 
\end_layout

\begin_layout Itemize
Do search algorithms with multiple-path pruning always halt on finite graphs?
 
\end_layout

\begin_layout Itemize
What is the space & time overhead of multiple-path pruning? 
\end_layout

\begin_layout Itemize
Can multiple-path pruning prevent an optimal solution being found? 
\begin_inset ERT
status open

\begin_layout Plain Layout

%What if you want the shortest path, but a subsequent path found is shorter
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

%than than first path found?
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Multiple-path pruning & Optimal solutions
\end_layout

\end_inset


\end_layout

\begin_layout Frame
What if a subsequent path to 
\begin_inset Formula $n$
\end_inset

 is shorter than the first path to 
\begin_inset Formula $n$
\end_inset

?
\end_layout

\begin_layout Frame
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Frame
Possible solutions:
\end_layout

\begin_deeper
\begin_layout Itemize
Remove all paths from the frontier that use the longer path.
 
\end_layout

\begin_layout Itemize
Change the initial segment of the paths on the frontier to use the shorter
 path.
 
\end_layout

\begin_layout Itemize
Ensure this doesn't happen.
 Make sure that the shortest path to a node is found first.
 
\end_layout

\end_deeper
\begin_layout Separator
 
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Multiple-path pruning & 
\begin_inset Formula $A^{*}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Suppose path 
\begin_inset Formula $p$
\end_inset

 to 
\begin_inset Formula $n$
\end_inset

 was selected, but there is a shorter path to
\begin_inset space ~
\end_inset


\begin_inset Formula $n$
\end_inset

.
 Suppose this shorter path is via path 
\begin_inset Formula $p'$
\end_inset

 on the frontier.
 
\end_layout

\begin_layout Itemize
Suppose path 
\begin_inset Formula $p'$
\end_inset

 ends at node 
\begin_inset Formula $n'$
\end_inset

.
 
\end_layout

\begin_layout Itemize
\begin_inset Formula $p$
\end_inset

 was selected before 
\begin_inset Formula $p'$
\end_inset

, so: 
\begin_inset Formula $cost(p)+h(n)\leq cost(p')+h(n')$
\end_inset

.
 
\end_layout

\begin_layout Itemize
Suppose 
\begin_inset Formula $cost(n',n)$
\end_inset

 is the actual cost of a path from 
\begin_inset Formula $n'$
\end_inset

 to 
\begin_inset Formula $n$
\end_inset

.
 The path to 
\begin_inset Formula $n$
\end_inset

 via 
\begin_inset Formula $p'$
\end_inset

 is shorter that 
\begin_inset Formula $p$
\end_inset

 so: 
\begin_inset Formula $cost(p')+cost(n',n)<cost(p)$
\end_inset

.
\end_layout

\begin_layout Itemize
Combining the two:
\begin_inset Formula 
\[
cost(n',n)<cost(p)-cost(p')\leq h(n')-h(n)
\]

\end_inset


\end_layout

\begin_layout Itemize
We can ensure this doesn't occur if 
\begin_inset Formula $|h(n')-h(n)|\leq cost(n',n)$
\end_inset

.
 
\end_layout

\end_deeper
\begin_layout Separator
 
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Monotone restriction
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Heuristic function 
\begin_inset Formula $h$
\end_inset

 satisfies the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

monotone restriction
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 if 
\begin_inset Formula $|h(m)-h(n)|\leq cost(m,n)$
\end_inset

 for every arc 
\begin_inset Formula $\tuple{m,n}$
\end_inset

.
 
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $h$
\end_inset

 satisfies the monotone restriction, 
\begin_inset Formula $A^{*}$
\end_inset

 with multiple path pruning always finds the shortest path to a goal.
 
\end_layout

\begin_layout Itemize
This is a strengthening of the admissibility criterion.
 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Subsection
Iterative deepening (3.7.3)
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Iterative deepening
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
So far all search strategies that are guaranteed to halt use exponential
 space.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hilitec
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Idea:
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 recompute elements of the frontier rather than saving them.
\end_layout

\begin_layout Itemize
Look for paths of depth 0, then 1, then 2, then 3, etc.
\end_layout

\begin_layout Itemize
Depth-bounded depth-first search can do this in linear space.
\end_layout

\begin_layout Itemize
If a path cannot be found at 
\begin_inset Formula $depth\,bound$
\end_inset

, look for a path at 
\begin_inset Formula $depth\,bound+1$
\end_inset

.
 Increase 
\begin_inset Formula $depth\,bound$
\end_inset

 when the search fails unnaturally (
\begin_inset Formula $depth\,bound$
\end_inset

 was reached).
 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Iterative deepening search, 
\begin_inset Formula $bound=0$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/ids-progress1c.ps
	width 100text%

\end_inset

 
\end_layout

\end_deeper
\begin_layout Separator
 
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Iterative deepening search, 
\begin_inset Formula $bound=1$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/ids-progress2c.ps
	width 100text%

\end_inset

 
\end_layout

\end_deeper
\begin_layout Separator
 
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Iterative deepening search, 
\begin_inset Formula $bound=2$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/ids-progress3c.ps
	width 100text%

\end_inset

 
\end_layout

\end_deeper
\begin_layout Separator
 
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Iterative deepening search, 
\begin_inset Formula $bound=3$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/ids-progress4c.ps
	width 100text%

\end_inset

 
\end_layout

\end_deeper
\begin_layout Separator
 
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Iterative-deepening search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{pcode}
\end_layout

\end_inset

 
\begin_inset Newline newline
\end_inset


\series bold
procedure
\series default
 IDSearch(
\begin_inset Formula $graph$
\end_inset

, 
\begin_inset Formula $start$
\end_inset

, 
\begin_inset Formula $goal$
\end_inset

):
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
for 
\begin_inset Formula $bound$
\end_inset

 in 
\begin_inset Formula $0,1,2,\dots$
\end_inset


\series default
:
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset Formula $result:=$
\end_inset

 BoundedDFSearch(
\begin_inset Formula $\tuple{s}$
\end_inset

, 
\begin_inset Formula $bound$
\end_inset

)
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
if
\series default
 
\begin_inset Formula $result$
\end_inset

 is a path 
\series bold
or
\series default
 
\begin_inset Formula $result$
\end_inset

 is failure:
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
return
\series default
 
\begin_inset Formula $result$
\end_inset


\begin_inset Newline newline
\end_inset


\series bold
end procedure
\series default
 IDSearch
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\series bold
procedure
\series default
 BoundedDFSearch(
\begin_inset Formula $\tuple{n_{0},\dots,n_{k}}$
\end_inset

, 
\begin_inset Formula $bound$
\end_inset

):
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
if
\series default
 
\begin_inset Formula $bound>0$
\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
for
\series default
 
\series bold
every
\series default
 neighbor 
\begin_inset Formula $n$
\end_inset

 of 
\begin_inset Formula $n_{k}$
\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset

BoundedDFSearch(
\begin_inset Formula $\tuple{n_{0},\dots,n_{k},n},bound-1$
\end_inset

)
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
else if
\series default
 
\begin_inset Formula $goal(n_{k})$
\end_inset


\series bold
:
\series default
 
\series bold
return
\series default
 path 
\begin_inset Formula $\tuple{n_{0},\dots,n_{k}}$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
else: return
\series default
 failure
\begin_inset Newline newline
\end_inset


\series bold
end procedure
\series default
 BoundedDFSearch
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{pcode}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Iterative deepening complexity
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Complexity with solution at depth 
\begin_inset Formula $k$
\end_inset

 and branching factor 
\begin_inset Formula $b$
\end_inset

: 
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="4">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
level 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
breadth-first 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
iterative deepening 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
# nodes 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $k$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $b$
\end_inset

 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $k-1$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $b^{2}$
\end_inset

 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
…
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
…
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
…
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
…
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $k-1$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $b^{k-1}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $k$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $b^{k}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
total
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${}\geq b^{k}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${}\leq b^{k}\left(\frac{b}{b-1}\right)^{2}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Numerical comparison for 
\begin_inset Formula $k=5$
\end_inset

 and 
\begin_inset Formula $b=10$
\end_inset

: 
\end_layout

\begin_layout Standard
\begin_inset Formula $\begin{array}{ccccc}
\#(\mbox{BFS}) & = & 10+100+1,000+10,000+100,000 & = & 111,110\\
\#(\mbox{IDS}) & = & 50+400+3,000+20,000+100,000 & = & 123,450
\end{array}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Alert
status open

\begin_layout Plain Layout
Note
\end_layout

\end_inset

: IDS recalculates shallow nodes several times, but this doesn't have a
 big effect compared to BFS! 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Subsection
Branch-and-bound (3.7.4)
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Depth-first Branch-and-Bound
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Way to combine depth-first search with heuristic information.
 
\end_layout

\begin_layout Itemize
Finds optimal solution.
 
\end_layout

\begin_layout Itemize
Most useful when there are multiple solutions, and we want an optimal one.
 
\end_layout

\begin_layout Itemize
Uses the space of depth-first search.
 
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
item The amount of recomputing the frontier can be controlled.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Depth-first Branch-and-Bound
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Idea: maintain the cost of the lowest-cost path found to a goal so far,
 call this 
\begin_inset Formula $bound$
\end_inset

.
 
\end_layout

\begin_layout Itemize
If the search encounters a path 
\begin_inset Formula $p$
\end_inset

 such that 
\begin_inset Formula $cost(p)+h(p)\geq bound$
\end_inset

, path 
\begin_inset Formula $p$
\end_inset

 can be pruned.
 
\end_layout

\begin_layout Itemize
If a non-pruned path to a goal is found, it must be better than the previous
 best path.
 This new solution is remembered and 
\begin_inset Formula $bound$
\end_inset

 is set to its cost.
 
\end_layout

\begin_layout Itemize
The search can be a depth-first search to save space.
 
\end_layout

\begin_layout Itemize
How should the bound be initialized? 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Depth-first Branch-and-Bound: Initializing Bound
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The bound can be initialized to 
\begin_inset Formula $\infty$
\end_inset

.
 
\end_layout

\begin_layout Itemize
The bound can be set to an estimate of the optimal path cost.
 After depth-first search terminates either: 
\end_layout

\begin_deeper
\begin_layout Itemize
A solution was found.
 
\end_layout

\begin_layout Itemize
No solution was found, and no path was pruned 
\end_layout

\begin_layout Itemize
No solution was found, and a path was pruned.
 
\end_layout

\end_deeper
\end_deeper
\end_inset


\end_layout

\begin_layout Separator
 
\end_layout

\begin_layout Subsection
Direction of search (3.7.5)
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Direction of search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The definition of searching is symmetric: find path from start nodes to
 goal node or from goal node to start nodes.
 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Forward branching factor:
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 number of arcs out of a node.
 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Backward branching factor:
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 number of arcs into a node.
 
\end_layout

\begin_layout Itemize
Search complexity is 
\begin_inset Formula $b^{n}$
\end_inset

.
 Should use forward search if forward branching factor is less than backward
 branching factor, and vice versa.
 
\end_layout

\begin_layout Itemize
Note: when graph is dynamically constructed, the backwards graph may not
 be available.
 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Bidirectional search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Idea: search backward from the goal and forward from the start simultaneously.
\end_layout

\begin_layout Itemize
This wins as 
\begin_inset Formula $2b^{{k}/{2}}\ll b^{k}$
\end_inset

.
 This can result in an exponential saving in time and space.
\end_layout

\begin_layout Itemize
The main problem is making sure the frontiers meet.
\end_layout

\begin_layout Itemize
This is often used with one breadth-first method that builds a set of locations
 that can lead to the goal.
 In the other direction another method can be used to find a path to these
 interesting locations.
 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Island driven search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hilitec
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Idea:
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 find a set of islands between 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

.
 
\begin_inset Formula 
\[
s\longrightarrow i_{1}\longrightarrow i_{2}\longrightarrow\ldots\longrightarrow i_{m-1}\longrightarrow g
\]

\end_inset

This gives us 
\begin_inset Formula $m$
\end_inset

 smaller problems rather than 
\begin_inset Formula $1$
\end_inset

 big problem.
 
\end_layout

\begin_layout Itemize
This can win as 
\begin_inset Formula $mb^{{k}/{m}}\ll b^{k}$
\end_inset

.
 
\end_layout

\begin_layout Itemize
The problem is to identify the islands that the path must pass through.
 It is difficult to guarantee optimality.
 
\end_layout

\begin_layout Itemize
The subproblems can be solved using islands 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
barrow
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

hierarchy of abstractions.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Subsection
Dynamic programming (3.7.6)
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Dynamic Programming
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hilitec
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Idea:
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 for statically stored graphs, build a table of 
\begin_inset Formula $dist(n)$
\end_inset

 the actual distance of the shortest path from node 
\begin_inset Formula $n$
\end_inset

 to a goal.
\end_layout

\begin_layout Plain Layout
This can be built backwards from the goal: 
\begin_inset Formula 
\[
dist(n)=\left\{ \begin{array}{ll}
0 & \hspace*{-1em}\mbox{if }is\_goal(n),\\
\min_{\tuple{n,m}\in A}(\left|\tuple{n,m}\right|+dist(m)) & \mbox{otherwise.}
\end{array}\right.
\]

\end_inset

This can be used locally to determine what to do.
\end_layout

\begin_layout Plain Layout
There are two main problems: 
\end_layout

\begin_layout Itemize
It requires enough space to store the graph.
\begin_inset Newline newline
\end_inset

 
\end_layout

\begin_layout Itemize
The 
\begin_inset Formula $dist$
\end_inset

 function needs to be recomputed for each goal.
 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\end_inset


\end_layout

\end_body
\end_document
