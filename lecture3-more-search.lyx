#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass beamer
\begin_preamble
\usepackage{cibeamer}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 10
\spacing single
\use_hyperref false
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 0
\use_package cancel 0
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 0
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%% Lecture for Artificial Intelligence, Chapter 4, http://artint.info 
\end_layout

\begin_layout Plain Layout

%% Copyright David L.
 Poole and Alan K.
 Mackworth, 2010-2013
\end_layout

\begin_layout Plain Layout

%% Copyright Peter Ljunglöf, 2015
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%% This work is licensed under CC BY-NC-SA 4.0, the Creative Commons
\end_layout

\begin_layout Plain Layout

%% Attribution-NonCommercial-ShareAlike 4.0 International License.
 
\end_layout

\begin_layout Plain Layout

%% To view a copy of this license: http://creativecommons.org/licenses/by-nc-sa/4.
0/
\end_layout

\end_inset


\end_layout

\begin_layout Title (Plain Frame)
Chapters 3--5: More search
\end_layout

\begin_layout Subtitle
DIT410/TIN173 Artificial Intelligence
\end_layout

\begin_layout Author
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Peter Ljunglöf
\end_layout

\end_inset

Peter Ljunglöf
\begin_inset Newline newline
\end_inset


\size footnotesize

\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

(inspired by slides by Poole & Mackworth, Russell & Norvig, et al)
\end_layout

\begin_layout Date
12 April, 2016
\end_layout

\begin_layout PlainFrame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Outline
\end_layout

\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
AtBeginSubsection[]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{frame}<beamer>[plain]{Outline}
\end_layout

\begin_layout Plain Layout

    
\backslash
tableofcontents[currentsection,currentsubsection]
\end_layout

\begin_layout Plain Layout

  
\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
AtBeginSection[]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{frame}<beamer>[plain]{Outline}
\end_layout

\begin_layout Plain Layout

    
\backslash
tableofcontents[currentsection]
\end_layout

\begin_layout Plain Layout

  
\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
More search strategies (Russel & Norvig 3.4)
\end_layout

\begin_layout Subsection
Iterative deepening
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Iterative deepening
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
BFS is guaranteed to halt but uses exponential space.
\end_layout

\begin_layout Itemize
DFS uses linear space, but is not guaranteed to halt.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hilitec
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Idea:
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 take the best from BFS and DFS -- 
\begin_inset Newline newline
\end_inset

recompute elements of the frontier rather than saving them.
\end_layout

\begin_layout Itemize
Look for paths of depth 0, then 1, then 2, then 3, etc.
\end_layout

\begin_layout Itemize
Depth-bounded depth-first search can do this in linear space.
\end_layout

\begin_layout Itemize
If a path cannot be found at 
\family roman
\emph on
depth bound
\family default
\emph default
, look for a path at 
\family roman
\emph on
depth bound
\emph default
 + 1
\family default
.
 Increase 
\family roman
\emph on
depth bound
\family default
\emph default
 when the search fails unnaturally (
\family roman
\emph on
depth bound
\family default
\emph default
 was reached).
 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Iterative deepening search, 
\begin_inset Formula $bound=0$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/ids-progress1c.pdf
	width 100text%

\end_inset

 
\end_layout

\end_deeper
\begin_layout Separator
 
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Iterative deepening search, 
\begin_inset Formula $bound=1$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/ids-progress2c.pdf
	width 100text%

\end_inset

 
\end_layout

\end_deeper
\begin_layout Separator
 
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Iterative deepening search, 
\begin_inset Formula $bound=2$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/ids-progress3c.pdf
	width 100text%

\end_inset

 
\end_layout

\end_deeper
\begin_layout Separator
 
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Iterative deepening search, 
\begin_inset Formula $bound=3$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch03/ids-progress4c.pdf
	width 100text%

\end_inset

 
\end_layout

\end_deeper
\begin_layout Separator
 
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Iterative-deepening search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{pcode}
\end_layout

\end_inset

 
\begin_inset Newline newline
\end_inset


\series bold
procedure
\series default
 IDSearch(
\emph on
graph, initial-state, goal-state
\emph default
):
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
for 
\series default
\emph on
limit
\series bold
\emph default
 in 
\series default
0, 1, 2, \SpecialChar \ldots{}
:
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\emph on
result
\emph default
 := DepthLimitedSearch(
\emph on

\begin_inset Formula $\left\langle \textit{initial-state}\right\rangle $
\end_inset

, limit
\emph default
)
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
if
\series default
 
\emph on
result
\emph default
 
\begin_inset Formula $\neq$
\end_inset

 cutoff 
\series bold
then
\series default
 
\series bold
return
\series default
 
\emph on
result
\emph default

\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\series bold
procedure
\series default
 DepthLimitedSearch(
\begin_inset Formula $\tuple{n_{0},\dots,n_{k}}$
\end_inset

, 
\emph on
limit
\emph default
):
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
if
\series default
 
\begin_inset Formula $n_{k}$
\end_inset


\series bold
 
\series default
is a
\emph on
 goal-state
\series bold
\emph default
 then return
\series default
 path 
\begin_inset Formula $\tuple{n_{0},\dots,n_{k}}$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
else if
\series default
 
\emph on
limit
\emph default
 = 0
\series bold
 then return
\series default
 cutoff
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
else: 
\begin_inset Newline newline
\end_inset


\series default

\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\emph on
failure-type
\emph default
 := failure
\series bold

\begin_inset Newline newline
\end_inset


\series default

\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
for
\series default
 
\series bold
every
\series default
 neighbor 
\begin_inset Formula $n$
\end_inset

 of 
\begin_inset Formula $n_{k}$
\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\emph on
result
\emph default
 := DepthLimitedSearch(
\begin_inset Formula $\tuple{n_{0},\dots,n_{k},n}$
\end_inset

, 
\emph on
limit
\emph default
-1)
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
if
\series default
 
\emph on
result
\emph default
 is a path 
\series bold
then return 
\series default
\emph on
result
\emph default

\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
else if
\series default
 
\emph on
result
\emph default
 = cutoff 
\series bold
then
\series default
 
\emph on
failure-type
\emph default
 := cutoff
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
return
\series default
\emph on
 failure-type
\emph default

\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{pcode}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Iterative deepening complexity
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Complexity with solution at depth 
\begin_inset Formula $k$
\end_inset

 and branching factor 
\begin_inset Formula $b$
\end_inset

: 
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="4">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
level 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
breadth-first 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
iterative deepening 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
# nodes 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $k$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $b$
\end_inset

 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $k-1$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $b^{2}$
\end_inset

 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
…
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
…
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
…
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
…
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $k-1$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $b^{k-1}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $k$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $b^{k}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
total
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${}\geq b^{k}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${}\leq b^{k}\left(\frac{b}{b-1}\right)^{2}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Numerical comparison for 
\begin_inset Formula $k=5$
\end_inset

 and 
\begin_inset Formula $b=10$
\end_inset

: 
\end_layout

\begin_layout Standard
\begin_inset Formula $\begin{array}{ccccc}
\#(\mbox{BFS}) & = & 10+100+1,000+10,000+100,000 & = & 111,110\\
\#(\mbox{IDS}) & = & 50+400+3,000+20,000+100,000 & = & 123,450
\end{array}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Alert
status open

\begin_layout Plain Layout
Note
\end_layout

\end_inset

: IDS recalculates shallow nodes several times, 
\begin_inset Newline newline
\end_inset

but this doesn't have a big effect compared to BFS! 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Subsection
Bidirectional search
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Direction of search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The definition of searching is symmetric: find path from start nodes to
 goal node or from goal node to start nodes.
 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Forward branching factor:
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 number of arcs out of a node.
 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Backward branching factor:
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 number of arcs into a node.
 
\end_layout

\begin_layout Itemize
Search complexity is 
\begin_inset Formula $b^{n}$
\end_inset

.
 Should use forward search if forward branching factor is less than backward
 branching factor, and vice versa.
 
\end_layout

\begin_layout Itemize
Note: when a graph is dynamically constructed, the backwards graph may not
 be available.
 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Bidirectional search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Idea: search backward from the goal and forward from the start simultaneously.
\end_layout

\begin_layout Itemize
This wins as 
\begin_inset Formula $2b^{{k}/{2}}\ll b^{k}$
\end_inset

.
 This can result in an exponential saving in time and space.
\end_layout

\begin_layout Itemize
The main problem is making sure the frontiers meet.
\end_layout

\begin_layout Itemize
This is often used with one breadth-first method that builds a set of locations
 that can lead to the goal.
 In the other direction another method can be used to find a path to these
 interesting locations.
 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Island driven search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hilitec
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Idea:
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 find a set of islands between 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

.
 
\begin_inset Formula 
\[
s\longrightarrow i_{1}\longrightarrow i_{2}\longrightarrow\ldots\longrightarrow i_{m-1}\longrightarrow g
\]

\end_inset

This gives us 
\begin_inset Formula $m$
\end_inset

 smaller problems rather than 
\begin_inset Formula $1$
\end_inset

 big problem.
 
\end_layout

\begin_layout Itemize
This can win as 
\begin_inset Formula $mb^{{k}/{m}}\ll b^{k}$
\end_inset

.
 
\end_layout

\begin_layout Itemize
The problem is to identify the islands that the path must pass through.
 It is difficult to guarantee optimality.
 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Subsection
Dynamic programming (3.7.6)
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Dynamic Programming
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hilitec
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Idea:
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 for statically stored graphs, build a table of 
\begin_inset Formula $dist(n)$
\end_inset

 the actual distance of the shortest path from node 
\begin_inset Formula $n$
\end_inset

 to a goal.
\end_layout

\begin_layout Plain Layout
This can be built backwards from the goal: 
\begin_inset Formula 
\[
dist(n)=\left\{ \begin{array}{ll}
0 & \hspace*{-1em}\mbox{if }is\_goal(n),\\
\min_{\tuple{n,m}\in A}(\left|\tuple{n,m}\right|+dist(m)) & \mbox{otherwise.}
\end{array}\right.
\]

\end_inset

This can be used locally to determine what to do.
\end_layout

\begin_layout Plain Layout
There are two main problems: 
\end_layout

\begin_layout Itemize
It requires enough space to store the graph.
\begin_inset Newline newline
\end_inset

 
\end_layout

\begin_layout Itemize
The 
\begin_inset Formula $dist$
\end_inset

 function needs to be recomputed for each goal.
 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\end_inset


\end_layout

\begin_layout Section
Local search (Russell & Norvig 4.1, Poole & Mackworth 4.8)
\end_layout

\begin_layout Subsection
Iterative best improvement
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Local search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Plain Layout
Local search / Greedy descent: 
\end_layout

\begin_layout Itemize
Maintain an assignment of a value to each variable 
\end_layout

\begin_layout Itemize
Repeat until a satisfying assignment is found: 
\begin_inset Newline newline
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
Select a variable to change 
\end_layout

\begin_layout Itemize
Select a new value for that variable 
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

% At each step, select a ``neighbor'' of the current assignment
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%  (e.g., one that improves some heuristic value).
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%Requires:
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
begin{itemize}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
item What is a neighbor?
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
item Which neighbor should be selected?
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
end{itemize}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%(Some methods maintain multiple assignments.)
\end_layout

\end_inset


\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Iterative improvement
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
In many optimization problems, the 
\emph on
path
\emph default
 is irrelevant
\end_layout

\begin_layout Itemize
the goal state itself is the solution
\end_layout

\begin_layout Standard
Then the state space can be the set of ``complete'' configurations
\end_layout

\begin_layout Itemize
e.g., for 8-queens, a configuration can be any board with 8 queens
\begin_inset Newline newline
\end_inset

(it is irrelevant in which order the queens are added)
\end_layout

\begin_layout Standard
In such cases, we can use 
\emph on
iterative improvement
\emph default
 algorithms;
\begin_inset Newline newline
\end_inset

we keep a single 
\begin_inset Quotes eld
\end_inset

current
\begin_inset Quotes erd
\end_inset

 state, and try to improve it
\end_layout

\begin_layout Itemize
e.g., for 8-queens, we start with 8 queens on the board, 
\begin_inset Newline newline
\end_inset

and gradually move some queen to a better place
\end_layout

\begin_layout Standard
The goal would be to find an optimal configuration
\end_layout

\begin_layout Itemize
e.g., for 8-queens, where no queen is threatened
\end_layout

\begin_layout Standard
This takes constant space, and is suitable for online and offline search
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example: 
\begin_inset Formula $n$
\end_inset

-queens
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Put 
\begin_inset Formula $n$
\end_inset

 queens on an 
\begin_inset Formula $n\times n$
\end_inset

 board, in separate columns
\end_layout

\begin_layout Itemize
Move a queen to reduce the number of conflicts;
\begin_inset Newline newline
\end_inset

 repeat until we cannot move any queen anymore
\end_layout

\begin_deeper
\begin_layout Itemize
then we are at a local maximum, hopefully it is global too
\end_layout

\end_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename figures/ch04/4queens-iterative.pdf
	width 70text%

\end_inset

 
\end_layout

\begin_layout Standard
This almost always solves 
\begin_inset Formula $n$
\end_inset

-queens problems almost instantaneously for very large 
\begin_inset Formula $n$
\end_inset

 (e.g., 
\begin_inset Formula $n$
\end_inset

 = 1 
\emph on
million
\emph default
) 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example: Travelling salesperson
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Start with any complete tour, and perform pairwise exchanges
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename figures/ch04/tsp-sequence.pdf
	width 70text%

\end_inset

 
\end_layout

\begin_layout Standard
Variants of this approach get within 1% of optimal very quickly 
\begin_inset Newline newline
\end_inset

with thousands of cities
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Hill climbing (or gradient ascent/descent)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{pcode}
\end_layout

\end_inset

 
\series bold

\begin_inset Newline newline
\end_inset

procedure
\series default
 HillClimbing(
\emph on
graph, initial-state
\emph default
):
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\emph on
current 
\emph default
:= 
\emph on
initial-state
\emph default

\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
loop
\series default
:
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\emph on
neighbor
\emph default
 := a highest-valued successor of 
\emph on
current
\emph default

\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
if
\series default
 
\emph on
neighbor 
\emph default
value 
\begin_inset Formula $\leq$
\end_inset

 
\emph on
current
\emph default
 value
\series bold
 then return
\series default
 
\emph on
current
\emph default

\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\emph on
child
\emph default
 := 
\emph on
neighbor
\emph default

\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{pcode}
\end_layout

\end_inset

 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The state space landscape
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename figures/ch04/hill-climbing.pdf
	width 70text%

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace -0.3in*
\end_inset

Random-restart hill climbing:
\end_layout

\begin_layout Itemize
overcomes local maxima
\end_layout

\begin_layout Itemize
always finds the global maximum (given enough time)
\end_layout

\begin_layout Standard
Random sideways moves:
\end_layout

\begin_layout Itemize
escapes from shoulder, but loops on flat maxima
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Subsection
Randomized algorithms
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Randomized algorithms
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Consider two methods to find a minimum value: 
\end_layout

\begin_deeper
\begin_layout Itemize
Greedy ascent, starting from some position, 
\begin_inset Newline newline
\end_inset

keep moving upwards, 
\begin_inset Newline newline
\end_inset

and report maximum value found 
\end_layout

\begin_layout Itemize
Pick values at random, and report maximum value found 
\end_layout

\end_deeper
\begin_layout Itemize
Which do you expect to work better to find a global maximum? 
\end_layout

\begin_layout Itemize
Can a mix work better? 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Randomized hill climbing
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
As well as upward steps we can allow for: 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Random steps:
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 move to a random neighbor.
 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Random restart:
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 reassign random values to all variables.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Which is more expensive computationally? 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
1-dimensional illustrative example
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Two 1-dimensional search spaces; step right or left: 
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="right" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/ch04/hills.png
	width 80text%

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
Which method would most easily find the global maximum? 
\end_layout

\begin_deeper
\begin_layout Itemize
random steps or random restarts?
\end_layout

\end_deeper
\begin_layout Itemize
What happens in hundreds or thousands of dimensions? 
\end_layout

\begin_deeper
\begin_layout Itemize
e.g., where different dimensions have different structure? 
\end_layout

\end_deeper
\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Stochastic local search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Stochastic local search is a mix of: 
\end_layout

\begin_layout Itemize
Greedy ascent: move to a highest neighbor 
\end_layout

\begin_layout Itemize
Random walk: taking some random steps 
\end_layout

\begin_layout Itemize
Random restart: reassigning values to all variables 
\end_layout

\begin_layout Standard
One example of this is 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

simulated annealing
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

:
\end_layout

\begin_layout Itemize
the probability for taking a random step is gradually decreased while the
 search algorithm is running
\end_layout

\end_deeper
\begin_layout Separator
\begin_inset Note Note
status collapsed

\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Random walk
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Plain Layout
Variants of random walk: 
\end_layout

\begin_layout Itemize
When choosing the best variable-value pair, randomly sometimes choose a
 random variable-value pair.
 
\end_layout

\begin_layout Itemize
When selecting a variable then a value: 
\end_layout

\begin_deeper
\begin_layout Itemize
Sometimes choose any variable that participates in the most conflicts.
 
\end_layout

\begin_layout Itemize
Sometimes choose any variable that participates in any conflict (a red node).
 
\end_layout

\begin_layout Itemize
Sometimes choose any variable.
 
\end_layout

\end_deeper
\begin_layout Itemize
Sometimes choose the best value and sometimes choose a random value.
 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Variant: Simulated annealing
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Pick a variable at random and a new value at random.
 
\end_layout

\begin_layout Itemize
If it is an improvement, adopt it.
 
\end_layout

\begin_layout Itemize
If it isn't an improvement, adopt it probabilistically depending on a temperatur
e parameter, 
\begin_inset Formula $T$
\end_inset

.
 
\end_layout

\begin_deeper
\begin_layout Itemize
With current assignment 
\begin_inset Formula $n$
\end_inset

 and proposed assignment 
\begin_inset Formula $n'$
\end_inset

 we move to 
\begin_inset Formula $n'$
\end_inset

 with probability 
\begin_inset Formula $e^{({h(n')-h(n)})/{T}}$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Itemize
Temperature can be reduced.
 
\end_layout

\begin_layout Plain Layout
Probability of accepting a change: 
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Temperature 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1-worse 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2-worse 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3-worse
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.91 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.81 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.74
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.37 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.14 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.05
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.25 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.02 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.0003 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000006
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.1 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.00005 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2\times10^{-9}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $9\times10^{-14}$
\end_inset

 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Tabu lists
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
To prevent cycling we can maintain a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hiliteb
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

tabu list
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 of the 
\begin_inset Formula $k$
\end_inset

 last assignments.
 
\end_layout

\begin_layout Itemize
Don't allow an assignment that is already on the tabu list.
 
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $k=1$
\end_inset

, we don't allow an assignment of to the same value to the variable chosen.
 
\end_layout

\begin_layout Itemize
We can implement it more efficiently than as a list of complete assignments.
 
\end_layout

\begin_layout Itemize
It can be expensive if 
\begin_inset Formula $k$
\end_inset

 is large.
 
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Separator

\end_layout

\begin_layout Subsection
Population-based methods
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Parallel search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Plain Layout
A total assignment is called an 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
keyword
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

individual
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hilitec
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Idea:
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 maintain a population of 
\begin_inset Formula $k$
\end_inset

 individuals instead of one.
 
\end_layout

\begin_layout Itemize
At every stage, update each individual in the population.
 
\end_layout

\begin_layout Itemize
Whenever an individual is a solution, it can be reported.
 
\end_layout

\begin_layout Itemize
Like 
\begin_inset Formula $k$
\end_inset

 restarts, but uses 
\begin_inset Formula $k$
\end_inset

 times the minimum number of steps.
 
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Beam search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hilitec
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Idea:
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 maintain a population of 
\begin_inset Formula $k$
\end_inset

 states in parallel,
\begin_inset Newline newline
\end_inset

 instead of one:
\end_layout

\begin_layout Itemize
At every stage, choose the 
\begin_inset Formula $k$
\end_inset

 best out of all of the neighbors.
 
\end_layout

\begin_layout Itemize
When 
\begin_inset Formula $k=1$
\end_inset

, it is greedy descent.
 
\end_layout

\begin_layout Itemize
When 
\begin_inset Formula $k=\infty$
\end_inset

, it is breadth-first search.
 
\end_layout

\begin_layout Itemize
The value of 
\begin_inset Formula $k$
\end_inset

 lets us limit space and parallelism.
 
\end_layout

\begin_layout Itemize

\emph on
Note
\emph default
: this is not the same as 
\begin_inset Formula $k$
\end_inset

 searches run in parallel! 
\end_layout

\begin_layout Itemize

\emph on
Problem
\emph default
: quite often, all 
\begin_inset Formula $k$
\end_inset

 states end up on the same local hill.
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Stochastic beam search
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Like beam search, but it probabilistically chooses 
\begin_inset Newline newline
\end_inset

the 
\begin_inset Formula $k$
\end_inset

 individuals at the next generation:
\end_layout

\begin_layout Itemize
The probability that a neighbor is chosen is 
\begin_inset Newline newline
\end_inset

proportional to its heuristic value.
 
\end_layout

\begin_layout Itemize
This maintains diversity amongst the individuals.
 
\end_layout

\begin_layout Itemize
The heuristic value reflects the fitness of the individual.
 
\end_layout

\begin_layout Itemize
Like asexual reproduction: each individual mutates and 
\begin_inset Newline newline
\end_inset

the fittest ones survive.
 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Genetic algorithms
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Like stochastic beam search, but pairs of individuals 
\begin_inset Newline newline
\end_inset

are combined to create the offspring.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename figures/ch04/genetic.pdf
	width 80text%

\end_inset

 
\begin_inset VSpace -0.2in
\end_inset


\end_layout

\begin_layout Itemize
For each generation: 
\end_layout

\begin_deeper
\begin_layout Itemize
Randomly choose pairs of individuals where the fittest individuals are more
 likely to be chosen.
 
\end_layout

\begin_layout Itemize
For each pair, perform a cross-over: form two offspring 
\begin_inset Newline newline
\end_inset

each taking different parts of their parents: 
\end_layout

\begin_layout Itemize
Mutate some values.
 
\end_layout

\end_deeper
\begin_layout Itemize
Stop when a solution is found.
 
\end_layout

\end_deeper
\begin_layout Separator
\begin_inset Note Note
status collapsed

\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Genetic algorithm: Crossover
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Given two individuals: 
\begin_inset Formula 
\[
X_{1}=a_{1},X_{2}=a_{2},\dots,X_{m}=a_{m}
\]

\end_inset


\begin_inset Formula 
\[
X_{1}=b_{1},X_{2}=b_{2},\dots,X_{m}=b_{m}
\]

\end_inset


\end_layout

\begin_layout Itemize
Select 
\begin_inset Formula $i$
\end_inset

 at random.
 
\end_layout

\begin_layout Itemize
Form two offspring: 
\begin_inset Formula 
\[
X_{1}=a_{1},\dots,X_{i}=a_{i},X_{i+1}=b_{i+1},\dots,X_{m}=b_{m}
\]

\end_inset


\begin_inset Formula 
\[
X_{1}=b_{1},\dots,X_{i}=b_{i},X_{i+1}=a_{i+1},\dots,X_{m}=a_{m}
\]

\end_inset


\end_layout

\begin_layout Itemize
The effectiveness depends on the ordering of the variables.
 
\end_layout

\begin_layout Itemize
Many variations are possible.
 
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Separator

\end_layout

\begin_layout Subsection
Evaluating randomized algorithms (Poole & Mackworth 4.8.3)
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Comparing stochastic algorithms
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
How can you compare three algorithms 
\series bold
A
\series default
, 
\series bold
B
\series default
 and 
\series bold
C
\series default
, when 
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
A
\series default
 solves the problem 30% of the time very quickly 
\begin_inset Newline newline
\end_inset

but doesn't halt for the other 70% of the cases 
\end_layout

\begin_layout Itemize

\series bold
B
\series default
 solves 60% of the cases reasonably quickly 
\begin_inset Newline newline
\end_inset

but doesn't solve the rest 
\end_layout

\begin_layout Itemize

\series bold
C
\series default
 solves the problem in 100% of the cases, but slowly? 
\end_layout

\end_deeper
\begin_layout Itemize
Summary statistics, such as mean run time, median run time, and mode run
 time don't make much sense.
 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Runtime distribution
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Plots runtime (or number of steps) and the proportion (or number) 
\begin_inset Newline newline
\end_inset

of the runs that are solved within that runtime.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ch04/runtimedistc.pdf
	width 70text%

\end_inset

 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Separator

\end_layout

\begin_layout Section
Games (Russell & Norvig 5.1--5.5)
\end_layout

\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Multiple agents
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Let's consider multiple agents, where: 
\end_layout

\begin_layout Itemize
the agents select actions autonomously
\end_layout

\begin_layout Itemize
each agent has its own information state
\end_layout

\begin_deeper
\begin_layout Itemize
they can have different information (even conflicting)
\end_layout

\end_deeper
\begin_layout Itemize
the outcome depends on the actions of all agents
\end_layout

\begin_layout Itemize
each agent has its own utility function 
\begin_inset Newline newline
\end_inset

(that depends on the total outcome)
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Types of agents
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
There are two extremes of multiagent systems: 
\end_layout

\begin_layout Description
Cooperative: The agents share the same utility function
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
Example:
\emph default
 Automatic trucks in a warehouse
\end_layout

\end_deeper
\begin_layout Description
Competetive: When one agent wins all other agents lose
\end_layout

\begin_deeper
\begin_layout Standard
A common special case is when 
\begin_inset Formula $\sum_{a}u_{a}(o)=0$
\end_inset

 for any outcome 
\begin_inset Formula $o$
\end_inset

.
 This is called a 
\emph on
zero-sum game
\emph default
.
\end_layout

\begin_layout Standard

\emph on
Example:
\emph default
 Most board games
\end_layout

\end_deeper
\begin_layout Standard
Many multiagent systems are between these two extremes.
\end_layout

\begin_layout Standard

\emph on
Example:
\emph default
 Long-distance bike races are usually both 
\emph on
cooperative
\emph default
 (the
\begin_inset space ~
\end_inset

bikers usually form clusters where they take turns in leading the
\begin_inset space ~
\end_inset

group), and 
\emph on
competetive 
\emph default
(only one of them can win in the end).
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Games as search problems
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
The main difference to chapters 3--4: 
\begin_inset Newline newline
\end_inset

now we have more than one agent that have different goals.
 
\end_layout

\begin_layout Itemize
All possible game sequences are represented in a game tree.
 
\end_layout

\begin_layout Itemize
The nodes are states of the game, e.g.
 board positions in chess.
 
\end_layout

\begin_layout Itemize
Initial state and terminal nodes.
 
\end_layout

\begin_layout Itemize
States are connected if there is a legal move/ply.
 
\end_layout

\begin_layout Itemize
Utility function (payoff function).
 
\end_layout

\begin_layout Itemize
Terminal nodes have utility values --1, 0 or +1.
\end_layout

\begin_deeper
\begin_layout Itemize
(some authors use 0, 
\begin_inset Formula $\nicefrac{1}{2}$
\end_inset

, and 1, confusingly)
\end_layout

\end_deeper
\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Types of games
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Graphics
	filename figures/ch05/game-types.pdf
	width 100text%

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Minimax search
\end_layout

\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Strategies for 2-player games
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Given two players called MAX and MIN, MAX wants to maximize the utility
 value.
 Since MIN wants to minimize the same value, MAX should choose the alternative
 that maximizes given that MIN minimized.
\end_layout

\begin_layout Standard
The Minimax algorithm gives perfect play for deterministic, perfect-information
 games:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{pcode}
\end_layout

\end_inset

 
\series bold
procedure
\series default
 Minimax(
\emph on
state
\emph default
):
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
if
\series default
 TerminalTest(
\emph on
state
\emph default
):
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
return
\series default
 Utility(
\emph on
state
\emph default
)
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\emph on
A
\emph default
 := Actions(
\emph on
state
\emph default
)
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
if
\series default
 
\emph on
state
\emph default
 is a MAX node:
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
return 
\series default

\begin_inset Formula $\max_{a\in A}$
\end_inset

 Minimax(
\emph on
state, a
\emph default
)
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
else if
\series default
 
\emph on
state
\emph default
 is a MIN node:
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
return 
\series default

\begin_inset Formula $\min_{a\in A}$
\end_inset

 Minimax(
\emph on
state, a
\emph default
)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{pcode}
\end_layout

\end_inset

 
\end_layout

\end_deeper
\begin_layout Separator
\begin_inset Note Note
status open

\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Perfect information games
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Perfect information games are solvable in a manner similar to fully observable
 single-agent systems.
 We can either do it backward using dynamic programming or forward using
 search.
\end_layout

\begin_layout Itemize
If two agents are competing so that a positive reward for one is a negative
 reward for the other agent, we have a two-agent 
\emph on
zero-sum game
\emph default
.
 
\end_layout

\begin_layout Itemize
The value of a game zero-sum game can be characterized by a single number
 that one agent is trying to maximize and the other agent is trying to minimize.
 
\end_layout

\begin_layout Itemize
This leads to a 
\emph on
minimax
\emph default
 strategy:
\end_layout

\begin_deeper
\begin_layout Itemize
A node is either a MAX node (if it is controlled by the maximising agent),
\end_layout

\begin_layout Itemize
or is a MIN node (if it is controlled by the minimising agent).
\end_layout

\end_deeper
\end_deeper
\end_inset


\end_layout

\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Minimax search: tic-tac-toe
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename figures/ch05/tictactoe.pdf
	width 70text%

\end_inset


\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Subsection
Alpha-beta pruning
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
\begin_inset Formula $\alpha-\beta$
\end_inset

 pruning
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Suppose, we reach a node 
\begin_inset Formula $t$
\end_inset

 in the game tree which has 
\begin_inset Newline newline
\end_inset

leaves 
\begin_inset Formula $t_{1}$
\end_inset

, \SpecialChar \ldots{}
, 
\begin_inset Formula $t_{k}$
\end_inset

 corresponding to moves of player MIN.
\end_layout

\begin_layout Itemize
Let 
\begin_inset Formula $\alpha$
\end_inset

 be the best value of a position on a path from 
\begin_inset Newline newline
\end_inset

the root node to 
\begin_inset Formula $t$
\end_inset

.
\end_layout

\begin_layout Itemize
Then, if any of the leaves evaluates to 
\begin_inset Formula $u(t_{i})\leq\alpha$
\end_inset

, 
\begin_inset Newline newline
\end_inset

we can discard 
\begin_inset Formula $t$
\end_inset

, because any further evaluation 
\begin_inset Newline newline
\end_inset

will not improve the value of 
\begin_inset Formula $t$
\end_inset

.
\end_layout

\begin_layout Itemize
Analogously, define 
\begin_inset Formula $\beta$
\end_inset

 values for evaluating MAX moves.
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Minimax example
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
The Minimax algorithm gives perfect play for deterministic, perfect-information
 games.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename figures/ch05/minimax.pdf
	width 80text%

\end_inset


\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Minimax example, with 
\begin_inset Formula $\alpha-\beta$
\end_inset

 pruning
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
This is how 
\begin_inset Formula $\alpha-\beta$
\end_inset

 pruning might work:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
only<1>{
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/ch05/alpha-beta-progress1c.pdf
	width 90text%

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\backslash
only<2>{
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/ch05/alpha-beta-progress2c.pdf
	width 90text%

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\backslash
only<3>{
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/ch05/alpha-beta-progress3c.pdf
	width 90text%

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\backslash
only<4>{
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/ch05/alpha-beta-progress4c.pdf
	width 90text%

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\backslash
only<5>{
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/ch05/alpha-beta-progress5c.pdf
	width 90text%

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
How efficient is 
\begin_inset Formula $\alpha-\beta$
\end_inset

 pruning?
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
The amount of pruning provided by the 
\begin_inset Formula $\alpha-\beta$
\end_inset

 algorithm 
\begin_inset Newline newline
\end_inset

depends on the ordering of the children of each node.
 
\end_layout

\begin_layout Itemize
It works best if a highest-valued child of a MAX node is selected first
 and if a lowest-valued child of a MIN node is returned first.
 
\end_layout

\begin_layout Itemize
In implementations of real games, much of the effort is made to try to ensure
 this outcome.
 
\end_layout

\begin_layout Itemize
With a 
\begin_inset Quotes eld
\end_inset

perfect ordering
\begin_inset Quotes erd
\end_inset

, the time complexity becomes 
\begin_inset Formula $O(b^{m/2})$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
this
\emph on
 doubles
\emph default
 the solvable search depth
\end_layout

\begin_layout Itemize
however, 
\begin_inset Formula $35^{40}$
\end_inset

 (for chess) or 
\begin_inset Formula $250^{80}$
\end_inset

 is still impossible\SpecialChar \ldots{}

\end_layout

\end_deeper
\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Minimax and real games
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Most real games are too big to carry out minimax search, even with 
\begin_inset Formula $\alpha-\beta$
\end_inset

 pruning.
 
\end_layout

\begin_layout Itemize
For these games, instead of stopping at leaf nodes, we have to use a cutoff
 test to decide when to stop.
\end_layout

\begin_layout Itemize
The value returned at the node where the algorithm stops is an estimate
 of the value for this node.
 
\end_layout

\begin_layout Itemize
The function used to estimate the value is an evaluation function.
 
\end_layout

\begin_layout Itemize
Much work goes into finding good evaluation functions.
 
\end_layout

\begin_layout Itemize
There is a trade-off between the amount of computation required to compute
 the evaluation function and the size of the search space that can be explored
 in any given time.
 
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Deterministic games in practice
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Chess: 
\begin_inset VSpace -0.3cm
\end_inset


\end_layout

\begin_layout Itemize
DeepBlue (IBM) beats world champion Garry Kasparov, 1997.
 
\end_layout

\begin_layout Itemize
Modern chess programs: Houdini, Critter, Stockfish.
 
\end_layout

\begin_layout Standard
Checkers/Othello/Reversi: 
\begin_inset VSpace -0.3cm
\end_inset


\end_layout

\begin_layout Itemize
Human champions refuse to compete -- computers are too good.
 
\end_layout

\begin_layout Itemize
Logistello beats the world champion in Othello/Reversi, 1997.
 
\end_layout

\begin_layout Itemize
Chinook plays checkers perfectly, 2007.
 It uses an endgame database defining perfect play for all 8-piece positions.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
 on the board, a total of 443,748,401,247 positions.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Go: 
\begin_inset VSpace -0.3cm
\end_inset


\end_layout

\begin_layout Itemize
Human champions refuse to compete -- computers are too bad.
\end_layout

\begin_layout Itemize
Modern programs: MoGo, Zen, GNU Go.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
pause 
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hilitec
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Breaking news, 14th March 2016!
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset VSpace -0.3cm
\end_inset


\end_layout

\begin_layout Itemize
AlphaGo (Google DeepMind) beats the world champion 4--1!
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Subsection
Nondeterministic games
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Nondeterministic games: backgammon
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename figures/ch05/backgammon-position.pdf
	width 60text%

\end_inset


\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Nondeterministic games in general
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
In nondeterministic games, chance is introduced by dice, card-shuffling,
 etc.
 
\end_layout

\begin_layout Standard
Simplified example with coin-flipping:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename figures/ch05/expectiminimax-simple.pdf
	width 60text%

\end_inset


\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Algorithm for nondeterministic games
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
The ExpectiMinimax algorithm gives perfect play
\end_layout

\begin_layout Itemize
it's just like Minimax, except we must also handle chance nodes
\end_layout

\begin_layout Standard
\begin_inset VSpace -0.3cm
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{pcode}
\end_layout

\end_inset

 
\series bold
procedure
\series default
 ExpectiMinimax(
\emph on
state
\emph default
):
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
if
\series default
 TerminalTest(
\emph on
state
\emph default
):
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
return
\series default
 Utility(
\emph on
state
\emph default
)
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\emph on
A
\emph default
 := Actions(
\emph on
state
\emph default
)
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
if
\series default
 
\emph on
state
\emph default
 is a MAX node:
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
return 
\series default

\begin_inset Formula $\max_{a\in A}$
\end_inset

 ExpectiMinimax(
\emph on
state, a
\emph default
)
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
else if
\series default
 
\emph on
state
\emph default
 is a MIN node:
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
return 
\series default

\begin_inset Formula $\min_{a\in A}$
\end_inset

 ExpectiMinimax(
\emph on
state, a
\emph default
)
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
else if
\series default
 
\emph on
state
\emph default
 is a chance node:
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
>
\end_layout

\end_inset


\series bold
return 
\series default

\begin_inset Formula $\sum_{a\in A}P(a)$
\end_inset

 ExpectiMinimax(
\emph on
state, a
\emph default
)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{pcode}
\end_layout

\end_inset

 
\begin_inset VSpace -0.3cm
\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $P(a)$
\end_inset

 is the probability that action 
\begin_inset Formula $a$
\end_inset

 occurs.
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Nondeterministic games in practice
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Dice rolls increase the branching factor 
\begin_inset Formula $b$
\end_inset

:
\end_layout

\begin_layout Itemize
there are 21 possible rolls with 2 dice 
\end_layout

\begin_layout Standard
Backgammon has 
\begin_inset Formula $\approx20$
\end_inset

 legal moves:
\end_layout

\begin_layout Itemize
depth 
\begin_inset Formula $4\Rightarrow20\times(21\times20)^{3}\approx1.2\times10^{9}$
\end_inset

 nodes
\end_layout

\begin_layout Standard
As depth increases, the probability of reaching a given node shrinks:
\end_layout

\begin_layout Itemize
value of lookahead is diminished
\end_layout

\begin_layout Itemize
\begin_inset Formula $\alpha-\beta$
\end_inset

 pruning is much less effective
\end_layout

\begin_layout Standard
TDGammon (1995) used depth-2 search + very good Eval: 
\end_layout

\begin_layout Itemize
the evaluation function was learned by self-play
\end_layout

\begin_layout Itemize
world-champion level
\end_layout

\end_deeper
\end_body
\end_document
